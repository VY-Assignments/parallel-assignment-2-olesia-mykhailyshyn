#include <queue>
#include <cstdlib>
#include <ctime>
#include <thread>
#include <chrono>
#include <iostream>
#include <functional>
#include <mutex>
#include <vector>
#include <condition_variable>
#include <atomic>
#include <map>

std::mutex metricsMutex;
double totalWaitTimeFirstQueue = 0;
double totalExecutionTimeFirstQueue = 0;
double totalWaitTimeSecondQueue = 0;
double totalExecutionTimeSecondQueue = 0;
int totalTasksProcessedFirstQueue = 0;
int totalTasksProcessedSecondQueue = 0;

std::atomic<int> activeThreads(0);
std::atomic<bool> immediateStop(false);
std::atomic<bool> paused(false);

std::map<int, std::chrono::high_resolution_clock::time_point> taskStartTimes;

std::queue<std::tuple<int, int, std::function<void()>>> tasksQueue;
std::mutex tasksGeneratorMutex;
std::condition_variable taskQueueCV;

auto comparator = [] (const std::tuple<int, int, std::function<void()>>& a,
                      const std::tuple<int, int, std::function<void()>>& b) {
    return std::get<0>(a) > std::get<0>(b);
};

std::priority_queue<std::tuple<int, int, std::function<void()>>,
        std::vector<std::tuple<int, int, std::function<void()>>>,
        decltype(comparator)> firstPriorityQueue(comparator);
std::mutex firstPriorityQueueMutex;
std::condition_variable firstPriorityQueueCV;

std::queue<std::tuple<int, std::function<void()>>> secondQueue;
std::mutex secondQueueMutex;
std::condition_variable secondQueueCV;

std::atomic<bool> stop(false);
const int maxTasks = 1;
int globalTaskId = 0;

void Generator(int taskDuration, int taskId) {
    if (std::rand() % 100 < 40) {
        taskDuration *= 3;
    }
    std::this_thread::sleep_for(std::chrono::seconds(taskDuration));
    std::cout << "Executing task " << taskId << " that took " << taskDuration << " seconds" << std::endl;
}

void TaskGenerator(int threadId, std::queue<std::tuple<int, int, std::function<void()>>>& taskQueue) {
    while (!immediateStop) {
        {
            std::unique_lock<std::mutex> lock(tasksGeneratorMutex);
            if (globalTaskId >= maxTasks) {
                std::cout << "Maximum number of tasks generated" << std::endl;
                break;
            }

            if (paused) {
                std::cout << "Generator paused by thread " << threadId << std::endl;
                taskQueueCV.wait(lock, [] { return !paused || immediateStop; });
                if (immediateStop) {
                    return;
                }
            }

            if (taskQueue.size() >= maxTasks) {
                taskQueueCV.wait(lock, [&taskQueue] { return taskQueue.size() < maxTasks || immediateStop; });
                if (immediateStop) {
                    return;
                }
            }

            int taskDuration = 5 + std::rand() % 6;
            int taskId = ++globalTaskId;
            taskQueue.push({taskDuration, taskId, [taskDuration, taskId]() { Generator(taskDuration, taskId); }});
            taskStartTimes[taskId] = std::chrono::high_resolution_clock::now();
            std::cout << "Task " << taskId << " generated by thread " << threadId << " with duration " << taskDuration << std::endl;
        }
        taskQueueCV.notify_one();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void TransferTasksToPriorityQueue() {
    while (!stop || !tasksQueue.empty()) {
        if (immediateStop) {
            return;
        }

        std::tuple<int, int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(tasksGeneratorMutex);
            taskQueueCV.wait(lock, [] { return !tasksQueue.empty() || stop || immediateStop; });
            if (immediateStop) {
                return;
            }

            if (tasksQueue.empty() && stop) {
                break;
            }

            if (!tasksQueue.empty()) {
                task = tasksQueue.front();
                tasksQueue.pop();
                std::cout << "Task " << std::get<1>(task) << " transferred from tasksQueue to firstPriorityQueue" << std::endl;
            }
        }

        {
            std::lock_guard<std::mutex> lock(firstPriorityQueueMutex);
            firstPriorityQueue.push(task);
            std::cout << "Task " << std::get<1>(task) << " added to firstPriorityQueue" << std::endl;
        }
        firstPriorityQueueCV.notify_one();
        taskQueueCV.notify_all();
    }
}

void WorkerFirstPriority(int workerId) {
    while (!stop || !firstPriorityQueue.empty()) {
        if (immediateStop) {
            return;
        }

        std::tuple<int, int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(firstPriorityQueueMutex);
            firstPriorityQueueCV.wait(lock, [] { return !firstPriorityQueue.empty() || stop || immediateStop; });
            if (immediateStop) {
                return;
            }

            if (!firstPriorityQueue.empty()) {
                task = firstPriorityQueue.top();
                firstPriorityQueue.pop();
                std::cout << "Worker " << workerId << " took task " << std::get<1>(task) << " from firstPriorityQueue" << std::endl;
            }
            else if (stop) {
                break;
            }
        }

        if (std::get<2>(task)) {
            auto startTime = taskStartTimes[std::get<1>(task)];
            auto dequeueTime = std::chrono::high_resolution_clock::now();
            activeThreads++;
            std::get<2>(task)();
            activeThreads--;
            auto endTime = std::chrono::high_resolution_clock::now();

            {
                std::lock_guard<std::mutex> lock(metricsMutex);
                totalWaitTimeFirstQueue += std::chrono::duration_cast<std::chrono::duration<double>>(dequeueTime - startTime).count();
                totalExecutionTimeFirstQueue += std::chrono::duration_cast<std::chrono::duration<double>>(endTime - dequeueTime).count();
                totalTasksProcessedFirstQueue++;
            }

            if (std::chrono::duration_cast<std::chrono::seconds>(endTime - dequeueTime).count() > 2 * std::get<0>(task)) {
                std::lock_guard<std::mutex> lock(secondQueueMutex);
                secondQueue.push({std::get<1>(task), std::get<2>(task)});
                secondQueueCV.notify_one();
                std::cout << "Worker " << workerId << " moved task " << std::get<1>(task) << " to secondQueue" << std::endl;
            } else {

                std::cout << "Worker " << workerId << " successfully completed task " << std::get<1>(task) << " in firstPriorityQueue" << std::endl;
            }

            {
                std::lock_guard<std::mutex> lock(metricsMutex);
                taskStartTimes.erase(std::get<1>(task));
            }
        }
    }
}

void WorkerSecondQueue(int workerId) {
    while (!stop || !secondQueue.empty()) {
        if (immediateStop) {
            return;
        }

        std::tuple<int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(secondQueueMutex);
            secondQueueCV.wait(lock, [] { return !secondQueue.empty() || stop || immediateStop; });
            if (immediateStop) {
                return;
            }

            if (secondQueue.empty() && stop) {
                break;
            }
            if (!secondQueue.empty()) {
                task = secondQueue.front();
                secondQueue.pop();
                std::cout << "Worker " << workerId << " took task " << std::get<0>(task) << " from secondQueue for execution" << std::endl;
            }
        }

        if (std::get<1>(task)) {
            auto startTime = std::chrono::high_resolution_clock::now();
            std::get<1>(task)();
            auto endTime = std::chrono::high_resolution_clock::now();

            {
                std::lock_guard<std::mutex> lock(metricsMutex);
                totalWaitTimeSecondQueue += std::chrono::duration_cast<std::chrono::duration<double>>(startTime - taskStartTimes[std::get<0>(task)]).count();
                totalExecutionTimeSecondQueue += std::chrono::duration_cast<std::chrono::duration<double>>(endTime - startTime).count();
                totalTasksProcessedSecondQueue++;
            }

            std::cout << "Worker " << workerId << " successfully completed task " << std::get<0>(task) << " from secondQueue" << std::endl;
        }
    }
}

int main() {
    std::srand(std::time(nullptr));

    std::thread generatorProcess1(TaskGenerator, 1, std::ref(tasksQueue));
    std::thread generatorProcess2(TaskGenerator, 2, std::ref(tasksQueue));

    std::thread taskTransferThread(TransferTasksToPriorityQueue);

    std::vector<std::thread> workersFirstQueue(3);
    for (int i = 0; i < workersFirstQueue.size(); ++i) {
        workersFirstQueue[i] = std::thread(WorkerFirstPriority, i + 1);
    }

    std::thread workerSecond(WorkerSecondQueue, 4);

    generatorProcess1.join();
    generatorProcess2.join();

    stop = true;
    taskQueueCV.notify_all();
    firstPriorityQueueCV.notify_all();
    secondQueueCV.notify_all();

    taskTransferThread.join();
    for (size_t i = 0; i < workersFirstQueue.size(); i++) {
        workersFirstQueue[i].join();
    }
    workerSecond.join();

    {
        std::lock_guard<std::mutex> lock(metricsMutex);
        std::cout << "\n\n=== Metrics ===" << std::endl;
        if (totalTasksProcessedFirstQueue > 0) {
            std::cout << "First Queue - Average wait time: " << totalWaitTimeFirstQueue / totalTasksProcessedFirstQueue << " seconds" << std::endl;
            std::cout << "First Queue - Average execution time: " << totalExecutionTimeFirstQueue / totalTasksProcessedFirstQueue << " seconds" << std::endl;
            std::cout << "First Queue - Total tasks processed: " << totalTasksProcessedFirstQueue << std::endl;
        }
        if (totalTasksProcessedSecondQueue > 0) {
            std::cout << "Second Queue - Average wait time: " << totalWaitTimeSecondQueue / totalTasksProcessedSecondQueue << " seconds" << std::endl;
            std::cout << "Second Queue - Average execution time: " << totalExecutionTimeSecondQueue / totalTasksProcessedSecondQueue << " seconds" << std::endl;
            std::cout << "Second Queue - Total tasks processed: " << totalTasksProcessedSecondQueue << std::endl;
        }
    }

    std::cout << "All tasks are completed." << std::endl;

    return 0;
}