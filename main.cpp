#include <queue>
#include <cstdlib>
#include <ctime>
#include <thread>
#include <chrono>
#include <iostream>
#include <functional>
#include <mutex>
#include <vector>
#include <condition_variable>
#include <atomic>

std::queue<std::tuple<int, int, std::function<void()>>> tasksQueue;
std::mutex tasksGeneratorMutex;
std::condition_variable taskQueueCV;

auto comparator = [] (const std::tuple<int, int, std::function<void()>>& a,
                      const std::tuple<int, int, std::function<void()>>& b) {
    return std::get<0>(a) > std::get<0>(b);
};

std::priority_queue<std::tuple<int, int, std::function<void()>>,
        std::vector<std::tuple<int, int, std::function<void()>>>,
        decltype(comparator)> firstPriorityQueue(comparator);
std::mutex firstPriorityQueueMutex;
std::condition_variable firstPriorityQueueCV;

std::queue<std::tuple<int, std::function<void()>>> secondQueue;
std::mutex secondQueueMutex;
std::condition_variable secondQueueCV;

std::atomic<bool> stop(false);
const int maxTasks = 5;
int globalTaskId = 0;

void Generator(int taskDuration, int taskId) {

    if (std::rand() % 100 < 20) {
        taskDuration *= 3;
    }

    std::this_thread::sleep_for(std::chrono::seconds(taskDuration));
    std::cout << "Executing task " << taskId << " that will take " << taskDuration << " seconds" << std::endl;
}

void TaskGenerator(int threadId, std::queue<std::tuple<int, int, std::function<void()>>>& taskQueue) {
    while (true) {
        {
            std::unique_lock<std::mutex> lock(tasksGeneratorMutex);
            if (globalTaskId >= maxTasks) {
                std::cout << "Maximum number of tasks generated" << std::endl;
                break;
            }

            if (taskQueue.size() >= maxTasks) {
                std::cout << "Task queue is full" << std::endl;
                taskQueueCV.wait(lock, [&taskQueue] { return taskQueue.size() < maxTasks; });
            }

            int taskDuration = 5 + std::rand() % 6;
            int taskId = ++globalTaskId;
            taskQueue.push({taskDuration, taskId, [taskDuration, taskId]() { Generator(taskDuration, taskId); }});
            std::cout << "Task " << taskId << " generated by thread " << threadId << std::endl;
        }
        taskQueueCV.notify_one();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void TransferTasksToPriorityQueue() {
    while (!stop || !tasksQueue.empty()) {
        std::tuple<int, int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(tasksGeneratorMutex);
            taskQueueCV.wait(lock, [] { return !tasksQueue.empty() || stop; });
            if (tasksQueue.empty() && stop) {
                break;
            }
            if (!tasksQueue.empty()) {
                task = tasksQueue.front();
                tasksQueue.pop();
                std::cout << "Task " << std::get<1>(task) << " transferred from tasksQueue to firstPriorityQueue" << std::endl;
            }
        }

        {
            std::lock_guard<std::mutex> lock(firstPriorityQueueMutex);
            firstPriorityQueue.push(task);
            std::cout << "Task " << std::get<1>(task) << " added to firstPriorityQueue" << std::endl;
        }
        firstPriorityQueueCV.notify_one();
        taskQueueCV.notify_all();
    }
}

void WorkerFirstPriority(int workerId) {
    while (!stop || !firstPriorityQueue.empty()) {
        std::tuple<int, int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(firstPriorityQueueMutex);
            firstPriorityQueueCV.wait(lock, [] { return !firstPriorityQueue.empty() || stop; });
            if (!firstPriorityQueue.empty()) {
                task = firstPriorityQueue.top();
                firstPriorityQueue.pop();
                std::cout << "Worker " << workerId << " took task " << std::get<1>(task) << " from firstPriorityQueue" << std::endl;
            }
            else if (stop) {
                break;
            }
        }

        if (std::get<2>(task)) {
            auto startTime = std::chrono::steady_clock::now();
            std::get<2>(task)();
            auto endTime = std::chrono::steady_clock::now();

            if (std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime).count() > 2 * std::get<0>(task)) {
                std::lock_guard<std::mutex> lock(secondQueueMutex);
                secondQueue.push({std::get<1>(task), std::get<2>(task)});
                secondQueueCV.notify_one();
                std::cout << "Worker " << workerId << " moved task " << std::get<1>(task) << " to secondQueue" << std::endl;
            }
            else {
                std::cout << "Worker " << workerId << " successfully completed task " << std::get<1>(task) << " in firstPriorityQueue" << std::endl;
            }
        }
    }
}

void WorkerSecondQueue(int workerId) {
    while (!stop || !secondQueue.empty()) {
        std::tuple<int, std::function<void()>> task;
        {
            std::unique_lock<std::mutex> lock(secondQueueMutex);
            secondQueueCV.wait(lock, [] { return !secondQueue.empty() || stop; });
            if (secondQueue.empty() && stop) {
                break;
            }
            if (!secondQueue.empty()) {
                task = secondQueue.front();
                secondQueue.pop();
                std::cout << "Worker " << workerId << " took task " << std::get<0>(task) << " from secondQueue for execution" << std::endl;
            }
        }

        if (std::get<1>(task)) {
            std::get<1>(task)();
            std::cout << "Worker " << workerId << " successfully completed task " << std::get<0>(task) << " from secondQueue" << std::endl;
        }
    }
}

int main() {
    std::srand(std::time(nullptr));

    std::thread generatorProcess1(TaskGenerator, 1, std::ref(tasksQueue));
    std::thread generatorProcess2(TaskGenerator, 2, std::ref(tasksQueue));

    std::thread taskTransferThread(TransferTasksToPriorityQueue);

    std::vector<std::thread> workersFirstQueue(3);
    for (int i = 0; i < workersFirstQueue.size(); ++i) {
        workersFirstQueue[i] = std::thread(WorkerFirstPriority, i + 1);
    }

    std::thread workerSecond(WorkerSecondQueue, 4);

    generatorProcess1.join();
    generatorProcess2.join();

    stop = true;
    taskQueueCV.notify_all();
    firstPriorityQueueCV.notify_all();
    secondQueueCV.notify_all();

    taskTransferThread.join();
    for (size_t i = 0; i < workersFirstQueue.size(); i++) {
        workersFirstQueue[i].join();
    }
    workerSecond.join();

    std::cout << "All tasks are completed" << std::endl;

    return 0;
}